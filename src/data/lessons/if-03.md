---
id: if-03
title: 'Graph of Stories: Mapping Narrative Structure'
moduleId: interactive-fiction
prerequisites:
  - if-02
estimatedTimeMinutes: 10
difficulty: intermediate
learningObjectives:
  - Analyze a story dictionary as a directed graph
  - Identify dead-end passages with no outgoing choices
  - Calculate branching factor to measure narrative complexity
keywords:
  - directed graph
  - dead end
  - branching factor
  - narratology
  - story structure
---

# Graph of Stories: Mapping Narrative Structure

## Analogy

Literary scholars have long drawn maps of narratives. Structuralists charted the "morphology" of folktales; narratologists diagrammed the temporal structure of novels. When we represent interactive fiction as a dictionary of passages linked by choices, we are building a **directed graph** — a mathematical structure with nodes (passages) and edges (choices pointing from one passage to another). Analyzing this graph lets us answer the same questions narratologists ask: Where does the story branch? Where does it converge? Where does it end? The difference is that we can answer computationally, across hundreds of passages in seconds.

## Key Concepts

### Stories as Directed Graphs

Every story dictionary from the previous lessons is already a directed graph:

:::definition
**Directed graph**: A set of nodes (passages) connected by directed edges (choices), where each edge points from one node to another. In a story graph, the direction represents narrative flow.
:::

:::definition
**Dead end**: A passage with no outgoing choices — a terminal node in the story graph. In narrative terms, this is an ending.
:::

```python
story = {
    "start": {
        "text": "A crossroads in the forest.",
        "choices": {"Go left": "cave", "Go right": "village"}
    },
    "cave": {
        "text": "A dark cave. Something glitters inside.",
        "choices": {"Enter": "treasure"}
    },
    "village": {
        "text": "A quiet village at dusk.",
        "choices": {}
    },
    "treasure": {
        "text": "You find ancient gold coins!",
        "choices": {}
    }
}
```

This story has 4 nodes and 3 edges. The nodes `"village"` and `"treasure"` are dead ends.

### Counting Passages and Links

We can measure basic properties of the story graph:

```python
num_passages = len(story)
num_links = sum(len(p["choices"]) for p in story.values())
print(f"Passages: {num_passages}")
print(f"Links: {num_links}")
# Output:
# Passages: 4
# Links: 3
```

### Finding Dead Ends

A dead end is any passage whose `"choices"` dictionary is empty. These are the story's endings:

```python
dead_ends = []
for passage_id, passage in story.items():
    if len(passage["choices"]) == 0:
        dead_ends.append(passage_id)

print("Dead ends:", sorted(dead_ends))
# Output: Dead ends: ['treasure', 'village']
```

We can also write this more concisely with a list comprehension:

```python
dead_ends = [pid for pid, p in story.items() if len(p["choices"]) == 0]
print("Dead ends:", sorted(dead_ends))
# Output: Dead ends: ['treasure', 'village']
```

### Branching Factor

The **branching factor** tells us how many choices the average passage offers. A higher branching factor means more reader agency; a lower one means a more linear narrative:

:::definition
**Branching factor**: The average number of outgoing choices per passage. Calculated as total number of links divided by total number of passages.
:::

```python
total_choices = sum(len(p["choices"]) for p in story.values())
avg_branching = total_choices / len(story)
print(f"Average branching factor: {avg_branching:.2f}")
# Output: Average branching factor: 0.75
```

A traditional linear novel has a branching factor of roughly 1.0 (each passage leads to exactly one next passage). A highly branching work might reach 2.0 or more.

### Putting It All Together

Here is a complete structural analysis of a story:

```python
story = {
    "start": {"text": "...", "choices": {"A": "a", "B": "b"}},
    "a": {"text": "...", "choices": {"C": "c"}},
    "b": {"text": "...", "choices": {"C": "c", "D": "d"}},
    "c": {"text": "...", "choices": {}},
    "d": {"text": "...", "choices": {}}
}

print(f"Passages: {len(story)}")
dead_ends = sorted([pid for pid, p in story.items() if len(p['choices']) == 0])
print(f"Dead ends: {dead_ends}")
total = sum(len(p['choices']) for p in story.values())
print(f"Branching factor: {total / len(story):.2f}")
# Output:
# Passages: 5
# Dead ends: ['c', 'd']
# Branching factor: 1.00
```

## Practice

:::try-it
Take the story dictionary from the lesson on "The Forking Path" (if-01) and compute its number of passages, number of links, list of dead ends, and average branching factor. Compare the branching factor to what you would expect from a linear story.
:::

## Transfer

In digital humanities, graph analysis of narrative structures reveals patterns invisible to close reading alone. Researchers have mapped the structure of *Choose Your Own Adventure* books, hypertext literature, and even historical simulation games. Metrics like branching factor, dead-end count, and graph diameter help scholars compare how different works distribute agency to their readers. A museum's floor plan, a Choose Your Own Adventure book, and a historical counterfactual simulation all share the same underlying graph structure — and the same analytical toolkit.

:::challenge
Given a museum-navigation story dict, find all dead-end passages and calculate the average branching factor.
:::

---challenges---

### Challenge: Map the Museum

- id: if-03-c1
- language: python
- difficulty: intermediate

#### Starter Code

```python
story = {
    "start": {
        "text": "The museum lobby.",
        "choices": {"Go left": "egypt", "Go right": "greece", "Go upstairs": "medieval"}
    },
    "egypt": {
        "text": "The Egyptian wing.",
        "choices": {"Examine sarcophagus": "sarcophagus", "Read hieroglyphs": "hieroglyphs"}
    },
    "greece": {
        "text": "The Greek wing.",
        "choices": {"View pottery": "pottery"}
    },
    "medieval": {
        "text": "The Medieval wing.",
        "choices": {}
    },
    "sarcophagus": {
        "text": "An ornate sarcophagus from the 18th dynasty.",
        "choices": {}
    },
    "hieroglyphs": {
        "text": "Ancient hieroglyphs tell the story of a forgotten pharaoh.",
        "choices": {}
    },
    "pottery": {
        "text": "Red-figure pottery depicting scenes from the Odyssey.",
        "choices": {}
    }
}

# Find all dead-end passages (no choices) and sort them alphabetically
# Calculate the average branching factor (total choices / total passages)

# Your code here
```

#### Expected Output

```
Dead ends: ['hieroglyphs', 'medieval', 'pottery', 'sarcophagus']
Average branching factor: 0.86
```

#### Hints

1. A dead end has `len(passage["choices"]) == 0`. Use a list comprehension and `sorted()`.
2. Sum all choice counts with `sum(len(p["choices"]) for p in story.values())`.
3. Divide total choices by `len(story)` and format to two decimal places with `:.2f`.

#### Solution

```python
story = {
    "start": {
        "text": "The museum lobby.",
        "choices": {"Go left": "egypt", "Go right": "greece", "Go upstairs": "medieval"}
    },
    "egypt": {
        "text": "The Egyptian wing.",
        "choices": {"Examine sarcophagus": "sarcophagus", "Read hieroglyphs": "hieroglyphs"}
    },
    "greece": {
        "text": "The Greek wing.",
        "choices": {"View pottery": "pottery"}
    },
    "medieval": {
        "text": "The Medieval wing.",
        "choices": {}
    },
    "sarcophagus": {
        "text": "An ornate sarcophagus from the 18th dynasty.",
        "choices": {}
    },
    "hieroglyphs": {
        "text": "Ancient hieroglyphs tell the story of a forgotten pharaoh.",
        "choices": {}
    },
    "pottery": {
        "text": "Red-figure pottery depicting scenes from the Odyssey.",
        "choices": {}
    }
}

dead_ends = sorted([pid for pid, p in story.items() if len(p["choices"]) == 0])
print("Dead ends:", dead_ends)

total_choices = sum(len(p["choices"]) for p in story.values())
avg_branching = total_choices / len(story)
print(f"Average branching factor: {avg_branching:.2f}")
```

