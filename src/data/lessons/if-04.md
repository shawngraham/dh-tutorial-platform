---
id: if-04
title: 'Generating Worlds: Procedural Story Fragments'
moduleId: interactive-fiction
prerequisites:
  - if-03
estimatedTimeMinutes: 10
difficulty: intermediate
learningObjectives:
  - Use random.choice and string formatting to procedurally generate passage text
  - Apply random.seed for reproducible, deterministic output
  - Connect procedural generation to Oulipo and combinatorial literature
keywords:
  - procedural generation
  - random.choice
  - random.seed
  - Oulipo
  - Calvino
  - string formatting
---

# Generating Worlds: Procedural Story Fragments

## Analogy

In 1960, the French literary group **Oulipo** (Ouvroir de litterature potentielle — "Workshop of Potential Literature") began exploring literature created through formal constraints and combinatorial methods. Raymond Queneau's *Cent mille milliards de poemes* offered ten sonnets whose lines could be freely recombined, yielding 100 trillion possible poems. Italo Calvino's *The Castle of Crossed Destinies* generated narratives from the combinatorial arrangement of tarot cards. These writers understood that a small set of elements plus a set of rules could produce a vast narrative space. In Python, `random.choice` and string templates give us the same power: define your word banks, define your template, and let the machine explore the space of possibilities.

## Key Concepts

### Word Banks and Templates

Procedural generation starts with two ingredients:
1. **Word banks** — lists of interchangeable elements (settings, objects, adjectives, actions)
2. **A template** — a string with placeholders that the word bank items fill

:::definition
**Procedural generation**: The algorithmic creation of content from rules and component parts, rather than manual authorship of each individual piece.
:::

```python
import random

settings = ["a quiet chapel", "a dusty attic", "a sunlit courtyard"]
objects = ["letter", "painting", "compass"]

template = "You discover a {obj} in {setting}."
result = template.format(
    obj=random.choice(objects),
    setting=random.choice(settings)
)
print(result)
```

Each run produces a different combination — but every result is grammatically valid and narratively plausible.

### Deterministic Output with random.seed

For testing, grading, and reproducibility, we need the "random" choices to be the same every time. The `random.seed()` function fixes the sequence of random numbers:

:::definition
**random.seed**: A function that initializes the random number generator to a fixed state, ensuring that subsequent calls to random functions produce the same sequence of results every time.
:::

```python
import random
random.seed(27)

colors = ["red", "blue", "green", "gold", "silver"]
print(random.choice(colors))  # Always: gold
print(random.choice(colors))  # Always: green
```

With `random.seed(27)`, the output is deterministic — essential for verifying that generated content matches expected results.

### Building a Passage Generator

We can combine multiple word banks with a template to generate complete passage descriptions:

```python
import random
random.seed(7)

rooms = ["a vaulted cellar", "a narrow corridor", "a reading room"]
adjectives = ["crumbling", "polished", "ornate"]
features = ["bookshelf", "doorway", "window"]
conditions = ["draped in cobwebs", "gleaming with fresh paint", "half-hidden by shadow"]

template = "You enter {room}. A {adj} {feature} is {condition}."

passage = template.format(
    room=random.choice(rooms),
    adj=random.choice(adjectives),
    feature=random.choice(features),
    condition=random.choice(conditions)
)
print(passage)
```

### Generating Multiple Passages

A loop lets us produce many unique passages from the same materials:

```python
import random
random.seed(0)

eras = ["Victorian", "Medieval", "Baroque"]
items = ["diary", "seal", "brooch"]
states = ["pristine", "weathered", "fragmentary"]

template = "A {state} {era} {item} awaits examination."

for i in range(3):
    text = template.format(
        state=random.choice(states),
        era=random.choice(eras),
        item=random.choice(items)
    )
    print(text)
```

### Connecting Generated Passages to Story Structure

We can combine procedural generation with the story dictionaries from earlier lessons to automatically populate a narrative graph:

```python
import random
random.seed(99)

rooms = ["archive", "gallery", "vault"]
descriptions = ["dimly lit", "sun-drenched", "echoing"]

story = {}
for i, room in enumerate(rooms):
    desc = random.choice(descriptions)
    story[room] = {
        "text": f"You enter the {desc} {room}.",
        "choices": {}
    }

# Link them in sequence
story["archive"]["choices"]["Continue"] = "gallery"
story["gallery"]["choices"]["Continue"] = "vault"

for pid, p in story.items():
    print(f"{pid}: {p['text']}")
```

This approach scales: with richer word banks, you can generate entire explorable worlds.

## Practice

:::try-it
Create word banks for historical periods (e.g., "Renaissance", "Enlightenment"), document types (e.g., "treatise", "letter"), and conditions (e.g., "well-preserved", "barely legible"). Write a template and generate 3 descriptions using `random.seed(10)`.
:::

## Transfer

Procedural generation is a core technique in both creative computing and digital humanities. Scholars use it to model the "possibility space" of literary forms — how many distinct sonnets can a given set of rhyme words produce? Game designers and digital artists use it to create vast, explorable worlds from compact rule sets. In DH research, procedural generation helps with synthetic data creation for testing text-analysis tools, with modeling variant readings in textual scholarship, and with building exploratory simulations of historical spaces where not every detail is documented. The Oulipo insight endures: constraint is not the enemy of creativity but its engine.

:::challenge
Generate 3 unique passage descriptions from word banks and a template. Use `random.seed(27)` to ensure that the sequence of random generations always comes out the same way (computers use pseudo-random number generators so if you specify a seed value to start those calculations, the 'random' elements thereafter will always fall out the same way). Once you know the code works feel free to change that number and re-run to see what else might happen, or delete that line altogether!
:::

---challenges---

### Challenge: The Procedural Archive

- id: if-04-c1
- language: python
- difficulty: intermediate

#### Starter Code

```python
import random
random.seed(27)

settings = ["a dusty archive", "a candlelit scriptorium", "a forgotten library", "a sunken cathedral", "a crumbling tower"]
adjectives = ["mysterious", "faded", "whispering", "shadowed", "luminous"]
objects = ["manuscript", "map", "portrait", "clock", "mirror"]
actions = ["flickers in the dim light", "hums with quiet energy", "is covered in strange symbols", "stands slightly ajar", "gathers dust on a pedestal"]

template = "You enter {setting}. A {adj} {obj} {action}."

# Generate and print 3 passage descriptions using random.choice
# Your code here
```

#### Expected Output

```
You enter a sunken cathedral. A whispering portrait hums with quiet energy.
 You enter a dusty archive. A mysterious portrait gathers dust on a pedestal.
 You enter a forgotten library. A whispering portrait stands slightly ajar.
```

#### Hints

1. Use a `for` loop with `range(3)` to generate three passages.
2. Call `random.choice()` separately for each word bank inside the loop.
3. Use `template.format(setting=..., adj=..., obj=..., action=...)` to fill the template.

#### Solution

```python
import random
random.seed(27)

settings = ["a dusty archive", "a candlelit scriptorium", "a forgotten library", "a sunken cathedral", "a crumbling tower"]
adjectives = ["mysterious", "faded", "whispering", "shadowed", "luminous"]
objects = ["manuscript", "map", "portrait", "clock", "mirror"]
actions = ["flickers in the dim light", "hums with quiet energy", "is covered in strange symbols", "stands slightly ajar", "gathers dust on a pedestal"]

template = "You enter {setting}. A {adj} {obj} {action}."

for i in range(3):
    setting = random.choice(settings)
    adj = random.choice(adjectives)
    obj = random.choice(objects)
    action = random.choice(actions)
    print(template.format(setting=setting, adj=adj, obj=obj, action=action))
```

